name: Build and Release

on:
  # Manual trigger for releases
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type (minor or patch)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  test:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Run unit tests
        run: |
          python -m unittest discover -s tests -v

  build-linux:
    name: Build Linux ${{ matrix.arch }}
    needs: test
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64, i686, arm64]
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Fetch all tags
        run: git fetch --tags --force
      
      - name: Set up QEMU for multi-platform builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/386,linux/arm64
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:latest
      
      - name: Calculate version
        id: version
        shell: bash
        run: |
          # Use version type from workflow input
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          
          # Call centralized version calculation script
          VERSION=$(.github/scripts/calculate-version.sh "${VERSION_TYPE}")
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Generated version: ${VERSION}"

      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Update version in files
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          python3 -c "
          import re
          version = '$VERSION'
          with open('chatrixcd/__init__.py', 'r') as f:
              content = f.read()
          content = re.sub(r'__version__ = \".*\"', f'__version__ = \"{version}\"', content)
          with open('chatrixcd/__init__.py', 'w') as f:
              f.write(content)
          print(f'Updated version to {version}')
          "
      
      - name: Map architecture to Docker platform
        id: platform
        run: |
          case "${{ matrix.arch }}" in
            x86_64) echo "platform=linux/amd64" >> $GITHUB_OUTPUT ;;
            i686)   echo "platform=linux/386" >> $GITHUB_OUTPUT ;;
            arm64)  echo "platform=linux/arm64" >> $GITHUB_OUTPUT ;;
          esac
      
      - name: Set LTO flag based on architecture
        id: lto
        run: |
          # Disable LTO for ARM64 to speed up compilation, enable for others
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            echo "flag=no" >> $GITHUB_OUTPUT
          else
            echo "flag=yes" >> $GITHUB_OUTPUT
          fi
      
      - name: Build with Nuitka using Docker Buildx
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.build
          platforms: ${{ steps.platform.outputs.platform }}
          target: export
          build-args: |
            ARCH=${{ matrix.arch }}
            ENABLE_LTO=${{ steps.lto.outputs.flag }}
          cache-from: type=gha,scope=build-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=build-${{ matrix.arch }}
          outputs: type=local,dest=.
      
      - name: Verify binary was created
        run: |
          ls -lh chatrixcd-linux-${{ matrix.arch }}
          file chatrixcd-linux-${{ matrix.arch }}
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: chatrixcd-linux-${{ matrix.arch }}
          path: |
            chatrixcd-linux-${{ matrix.arch }}
          retention-days: 90

  release:
    name: Create Release
    needs: [build-linux]
    runs-on: ubuntu-latest
    if: success()
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Fetch all tags
        run: git fetch --tags --force
      
      - name: Calculate version
        id: version
        shell: bash
        run: |
          # Use version type from workflow input
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          
          # Call centralized version calculation script
          VERSION=$(.github/scripts/calculate-version.sh "${VERSION_TYPE}")
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Generated version: ${VERSION}"
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Prepare release artifacts
        run: |
          mkdir -p release
          find artifacts -type f -exec cp {} release/ \;
          ls -lah release/
      
      - name: Update version in files (for release job)
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Update __init__.py
          sed -i "s/__version__ = \".*\"/__version__ = \"${VERSION}\"/" chatrixcd/__init__.py
          
          # Update setup.py
          sed -i "s/version=\".*\"/version=\"${VERSION}\"/" setup.py
          
          echo "Updated version to ${VERSION}"
      
      - name: Update CHANGELOG.md
        run: |
          export VERSION="${{ steps.version.outputs.version }}"
          RELEASE_DATE=$(date +%Y-%m-%d)
          export RELEASE_DATE
          
          # Use Python to update the changelog in a more reliable way
          python3 << 'PYTHON_SCRIPT'
          import re
          from datetime import datetime
          import os
          
          version = os.environ['VERSION']
          release_date = os.environ['RELEASE_DATE']
          
          # Read the current CHANGELOG.md
          with open('CHANGELOG.md', 'r') as f:
              content = f.read()
          
          # Find the Unreleased section
          # Pattern: ## [Unreleased] followed by content until next ## heading
          unreleased_pattern = r'## \[Unreleased\]\n(.*?)(?=\n## |\Z)'
          match = re.search(unreleased_pattern, content, re.DOTALL)
          
          if match:
              unreleased_content = match.group(1).strip()
              
              # If there's no content, add a placeholder
              if not unreleased_content:
                  unreleased_content = "No changes recorded."
              
              # Create the new version section
              new_version_section = f"\n## [{version}] - {release_date}\n\n{unreleased_content}\n"
              
              # Replace the Unreleased section with an empty one and add the new version
              # Find position where to insert: after ## [Unreleased] line
              unreleased_header_end = match.start() + len("## [Unreleased]\n")
              next_section_start = match.end()
              
              new_content = (
                  content[:unreleased_header_end] + 
                  new_version_section + 
                  content[next_section_start:]
              )
              
              # Update Version History section if it exists
              version_history_pattern = r'(## Version History\s*\n)'
              if re.search(version_history_pattern, new_content):
                  new_content = re.sub(
                      version_history_pattern,
                      f'\\1\n- **{version}** ({release_date})\n',
                      new_content
                  )
              
              # Write the updated content
              with open('CHANGELOG.md', 'w') as f:
                  f.write(new_content)
              
              print(f"Updated CHANGELOG.md with version {version}")
          else:
              print("Warning: Could not find Unreleased section in CHANGELOG.md")
          PYTHON_SCRIPT
      
      - name: Generate changelog
        id: changelog
        run: |
          export VERSION="${{ steps.version.outputs.version }}"
          
          # Get the latest tag (if any)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Extract the version-specific content from CHANGELOG.md
          python3 << 'PYTHON_SCRIPT'
          import re
          import os
          
          version = os.environ['VERSION']
          
          # Read CHANGELOG.md
          with open('CHANGELOG.md', 'r') as f:
              changelog_content = f.read()
          
          # Find the section for this version
          # Pattern: ## [VERSION] - DATE followed by content until next ## heading
          version_pattern = rf'## \[{re.escape(version)}\].*?\n(.*?)(?=\n## |\Z)'
          match = re.search(version_pattern, changelog_content, re.DOTALL)
          
          if match:
              version_notes = match.group(1).strip()
              with open('version_notes.md', 'w') as f:
                  f.write(version_notes)
              print(f"Extracted version notes for {version}")
          else:
              print(f"Warning: Could not find version notes for {version}")
              with open('version_notes.md', 'w') as f:
                  f.write("No release notes found in CHANGELOG.md")
          PYTHON_SCRIPT
          
          # Generate changelog from commits
          if [ -z "$LATEST_TAG" ]; then
            # No previous tag, get all commits
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges | head -20)
          else
            # Get commits since last tag
            COMMITS=$(git log "${LATEST_TAG}"..HEAD --pretty=format:"- %s (%h)" --no-merges | head -20)
          fi
          
          # Combine CHANGELOG.md content with commit log
          export COMMITS
          export LATEST_TAG
          cat version_notes.md > release_changelog.md
          if [ -n "$COMMITS" ]; then
            cat >> release_changelog.md << EOF
          
          ## Commit Log
          
          ${COMMITS}
          EOF
          fi
          if [ -n "$LATEST_TAG" ]; then
            cat >> release_changelog.md << EOF
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...${{ steps.version.outputs.version }}
          EOF
          fi
          
          echo "Generated changelog for version ${{ steps.version.outputs.version }}"
      
      - name: Commit version updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add chatrixcd/__init__.py setup.py CHANGELOG.md
          git commit -m "chore: bump version to ${{ steps.version.outputs.version }}" || true
          git push || true
      
      - name: Create Git tag
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${VERSION}" -m "${VERSION}" || true
          git push origin "${VERSION}" || true
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: ${{ steps.version.outputs.version }}
          body_path: release_changelog.md
          draft: false
          files: |
            release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
